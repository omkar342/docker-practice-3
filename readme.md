# Clone the repository

```bash
git clone
```

# Turn on docker by opening the docker desktop


# Docker Commands for docker-practice

- **Docker Build**: Builds an image from a Dockerfile

  ```
  docker build -t docker-practice .
  ```

- **Docker Run**: To run docker file

  ```
  docker run -d -p 3002:3000 -e PORT=3000 docker-practice
  ```

**Description**: Above Command runs a Docker container in detached mode (-d) with port mapping, mapping port 4000 on the host to port 3001 in the container. The container is named docker-practice.

- **Docker Execution**: To execute a command in a running Docker container, use the `docker exec` command. For example, to list the files in the root directory of a running container, you can run:

  ```
  docker exec -it <container_name_or_id> ls

  ```

**Docker Exec**: Executes a co mmand in a running Docker container. Replace <container_name_or_id> with the actual ID of the running Docker container where you want to execute the command.

# Dockerfile Explanation

## 1. `FROM node:20`

This instruction specifies the base image to use for building this Docker image. It instructs Docker to pull the official Node.js image with the tag `20`. This image contains the Node.js runtime environment.

## 2. `WORKDIR /app`

This instruction sets the working directory inside the Docker container to `/app`. Subsequent instructions will be executed relative to this directory.

## 3. `COPY . .`

This instruction copies all files and directories from the current directory on the host (where the Docker build context is located) to the `/app` directory inside the Docker container.

## 4. `RUN npm i`

This instruction runs the `npm install` command inside the Docker container. It installs the dependencies listed in the `package.json` file of the application.

## 5. `RUN npx prisma generate`

This instruction runs the Prisma CLI command `npx prisma generate` inside the Docker container. Prisma is a modern database toolkit used for database access in Node.js applications. This command generates Prisma client code based on your Prisma schema.

## 6. `RUN npm run build`

This instruction runs the `npm run build` command inside the Docker container. It typically compiles TypeScript code, bundles assets, or performs any other build steps defined in the `scripts` section of the `package.json` file.

## 7. `CMD ["node", "dist/index.js"]`

This instruction specifies the default command to run when a container is started from this Docker image. It runs the Node.js application entry point, which is typically the `index.js` file located in the `dist` directory after the build step.


# Docker Volumes Example

This example demonstrates how to use Docker volumes to persist data in a MongoDB container.

## Without Volumes

By default, when you run a MongoDB container without specifying a volume, the data stored inside the container is lost when the container is stopped or restarted.

```bash
# Start a MongoDB container
docker run -p 27017:27017 -d mongo

# Open MongoDB Compass and connect to the running container. Add some data to the database.

# Kill the container
docker kill <container_id>

# Restart the container
docker run -p 27017:27017 -d mongo

# Open MongoDB Compass again and try to explore the database. The data you added earlier is no longer present.
```

# With Volumes

To persist data across container restarts, you can use Docker volumes. Volumes are managed by Docker and provide a way to store data outside the container's filesystem.

```bash
# Create a volume
docker volume create volume_database

# Start a MongoDB container and mount the volume to the /data/db directory (where MongoDB stores its data)
docker run -v volume_database:/data/db -p 27017:27017 -d mongo

# Open MongoDB Compass and connect to the running container. Add some data to the database.

# Kill the container
docker kill <container_id>

# Restart the container, making sure to mount the same volume
docker run -v volume_database:/data/db -p 27017:27017 -d mongo
```

# Open MongoDB Compass again and explore the database. The data you added earlier is still present.


By using volumes, you can ensure that important data generated by containers is stored separately from the container's filesystem. This allows the data to survive container restarts and enables data persistence across different container instances.

# Additional Volume Commands

Here are a few additional commands related to volumes in Docker:

```bash

# List all volumes
docker volume ls

# Inspect a specific volume
docker volume inspect <volume_name>

# Remove a volume
docker volume rm <volume_name>

# Remove all unused volumes
docker volume prune


```

Networks
--------

In Docker, networks provide a way for containers to communicate with each other and with the outside world. By default, Docker containers are isolated and cannot communicate with each other directly. However, by attaching containers to the same network, you can enable communication between them.

![notion image](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fdd624914-6876-4b58-9694-424f7aa5e22a%2Ff8d2f448-458c-4839-8b3f-1dbfceafd38b%2FUntitled.png?table=block&id=2c840075-3b94-4a95-b4fd-00046e4cb77d&cache=v2)

#### [](https://app.100xdevs.com/courses/2/234/256#f5837f1555364420874ef1a6ca3e0418 "Understanding Networks")Understanding Networks

Let's explore how to make containers talk to each other using Docker networks:

1.  Clone the repository:

`git clone <https://github.com/100xdevs-cohort-2/week-15-live-2.2.git>`

1.  Navigate to the cloned repository:

`cd week-15-live-2.2`

1.  Build the Docker image:

`docker build -t image_tag .`

Replace `image_tag` with a meaningful tag for your image (e.g., `my-app`).

1.  Create a custom network:

`docker network create my_custom_network`

This command creates a new Docker network named `my_custom_network`.

1.  Start the backend container with the network attached:

`docker run -d -p 3000:3000 --name backend --network my_custom_network image_tag`

This command starts a container from the built image, maps port 3000 from the container to port 3000 on the host, names the container `backend`, and attaches it to the `my_custom_network` network.

1.  Start the MongoDB container on the same network:

`docker run -d -v volume_database:/data/db --name mongo --network my_custom_network -p 27017:27017 mongo`

This command starts a MongoDB container, mounts the `volume_database` volume to persist data, names the container `mongo`, attaches it to the `my_custom_network` network, and maps port 27017 from the container to port 27017 on the host.

1.  Check the logs to ensure the database connection is successful:

`docker logs <container_id>`

Replace `<container_id>` with the ID of the backend container. The logs should indicate a successful connection to the MongoDB database.

1.  Visit an endpoint in your application to ensure it can communicate with the database.

Note: If you don't need to access the MongoDB container from outside the Docker network, you can remove the `-p 27017:27017` port mapping.

![notion image](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fdd624914-6876-4b58-9694-424f7aa5e22a%2Fc488cbd1-e627-450b-8c30-2a22c6340451%2FUntitled.png?table=block&id=0dadc7c8-69e2-4e16-89e5-b348484451dc&cache=v2)

#### [](https://app.100xdevs.com/courses/2/234/256#ada426557e46444ca710469160bed29c "Types of Networks")Types of Networks

Docker provides different types of networks, each serving a specific purpose:

1.  Bridge: The default network driver for containers. When you run a container without specifying a network, it's attached to a bridge network. It provides a private internal network on the host machine, and containers on the same bridge network can communicate with each other using their container names or IP addresses.

1.  Host: This network removes the network isolation between the container and the Docker host, and uses the host's networking directly. Containers attached to the host network can directly access the host's network stack, which is useful for services that need to handle lots of traffic or expose many ports.

Example of running a container with the host network:

`docker run --network host my-image`

1.  None: This network disables networking for a container, providing complete network isolation. Containers attached to the "none" network have no external connectivity.

Example of running a container with no network:

`docker run --network none my-image`

1.  Overlay: Overlay networks allow communication between containers running on different Docker hosts, enabling multi-host networking. This is useful in swarm mode for connecting services across multiple nodes.

1.  Macvlan: Macvlan networks allow containers to have their own MAC addresses and appear as physical devices on the network. This is useful for legacy applications that expect to be directly connected to the physical network.

> By leveraging Docker networks, you can enable communication between containers, control network isolation, and architect multi-container applications effectively. Networks provide flexibility and scalability in managing container communication and connectivity.